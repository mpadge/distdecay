# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' rcpp_clusters
#'
#' Calculate clusters from covariance and distance matrices.
#' 
#' while not all allocated:
#'     i = station with highest covariance
#'     j = corresponding station
#'     if i unallocated:
#'         if j allocated:
#'             cluster (i) <- cluster (j)
#'         else:
#'             allocate i to new cluster
#'     cov (i, j) = 0.0
#'     cmax (i) = max (cov (i, ))
#' 
#' @noRd
rcpp_clusters <- function(dmat, cmat) {
    .Call(`_distdecay_rcpp_clusters`, dmat, cmat)
}

#' rcpp_calc_cov
#'
#' Calculate pairwise covariance matrix between input trip matrix. Upper
#' diagonal is between all trips **from** i and j; lower diagonal holds
#' covariances between all trips **to** j and i. This can't be done easily in
#' Armadillo because the zero entries need to be removed, and arma's inbuilt
#' cov function doesn't ignore zeros, and any nan or inf values generate
#' resultant NA covariances for the whole row.
#' 
#' @noRd
rcpp_calc_cov <- function(tmat) {
    .Call(`_distdecay_rcpp_calc_cov`, tmat)
}

#' rcpp_calc_mi
#'
#' Calculate pairwise Mutual Information matrix between input trip matrix.
#' Upper diagonal is between all trips **from** i and j; lower diagonal holds
#' covariances between all trips **to** j and i. The zero values can simply be
#' ignored here because all marginal and joint distributions are normalised by
#' total sums, which are unaffected by zeros.
#' 
#' In R terms, NI between x and y is calculated from
#' pxy <- cbind (x, y) / sum (x + y) # joint density
#' px <- rowSums (pxy) # marginal densities
#' py <- colSums (pxy)
#' fnull <- px %o% py # independent null model
#' xy <- ifelse (pxy > 0, log2 (pxy / fnull), 0)
#' mi <- sum (pxy * xy)
#' 
#' @noRd
rcpp_calc_mi <- function(tmat) {
    .Call(`_distdecay_rcpp_calc_mi`, tmat)
}

